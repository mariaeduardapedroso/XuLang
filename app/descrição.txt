Documento Técnico: XuLang - Proposta, Estrutura e Implementação

1. Proposta da Linguagem XuLang

XuLang é uma linguagem de programação didática e estruturada, projetada para ser um modelo simplificado de linguagens procedurais tradicionais. Seu principal objetivo é fornecer um ambiente claro e de fácil compreensão para o estudo de conceitos fundamentais de programação, como declaração de variáveis, comandos de entrada/saída, estruturas de controle e expressões.

1.1. O que XuLang faz?

XuLang é um compilador source-to-source que traduz o código-fonte escrito em XuLang (.xu) diretamente para um código-fonte equivalente na linguagem C.

Fluxo de Execução:

O usuário escreve um programa em XuLang.

O compilador (xu_compiler.py) processa o arquivo .xu.

O compilador gera o código C equivalente (saida.c).

O código C é compilado por um compilador C (como o GCC) em um executável nativo.

Este processo demonstra a arquitetura de compilação, onde a XuLang atua como uma linguagem de alto nível intermediária que se beneficia da portabilidade e da eficiência do código C gerado.

2. Estrutura da Linguagem (Tokens e Léxico)

O Analisador Léxico (Lexer) é a primeira fase do compilador, responsável por transformar a sequência de caracteres do código-fonte em uma sequência de unidades significativas chamadas Tokens.

2.1. Tokens e Palavras Reservadas

Tipo de Token

Palavra-chave/Símbolo

Descrição

Equivalente em C (se aplicável)

Palavras-chave

DECLARACOES

Marca o início da seção de declaração de variáveis.

-

Palavras-chave

PROGRAMA

Marca o início do bloco de comandos principal.

int main()

Tipos

INTEIRO

Tipo de dados para números inteiros.

int

Tipos

REAL

Tipo de dados para números de ponto flutuante.

double

Tipos

TEXTO

Tipo de dados para cadeias de caracteres.

char name[256]

Tipos

LOGICO

Tipo de dados booleano.

int (0 ou 1)

Comandos

LEIA

Comando para leitura de entrada (input).

scanf / fgets

Comandos

ESCREVA

Comando para escrita de saída (output).

printf

Estruturas

SE, ENTAO, SENAO

Estrutura condicional (if-else).

if, else

Estruturas

ENQUANTO

Estrutura de repetição (while).

while

Blocos

INICIO, FIM

Delimitadores de bloco de comandos.

{ e }

Lógicos

E, OU

Operadores lógicos.

&&, ||

Operadores

<-

Operador de atribuição.

=

Operadores

==, !=, <, >, <=, >=

Operadores relacionais.

==, !=, <, >, <=, >=

Delimitadores

:

Ponto e vírgula/separador.

;

Comentário

#...

Comentário de linha.

//...

2.2. Definições Léxicas (Expressões Regulares)

O Lexer utiliza expressões regulares para identificar os tokens:

Token

Regex

Notas sobre a Geração de Código

NUMINT

\d+

Traduzido diretamente como literal em C.

NUMREAL

\d+\.\d+

Traduzido diretamente como literal em C.

CADEIA

`"([^\\n]

(\.))*?"`

ATRIB

\<\-

Convertido para o operador de atribuição C, =.

NAME

[A-Za-z_][A-Za-z0-9_]*

Identificadores de variáveis. O Lexer verifica se são palavras reservadas (case-insensitive para XuLang) ou nomes de variáveis.

3. Gramática da Linguagem (Sintaxe)

O Analisador Sintático (Parser) utiliza a gramática Livre de Contexto abaixo, definida no formato BNF (Backus-Naur Form), para determinar se a sequência de tokens é válida.

3.1. Estrutura do Programa

O programa é dividido em uma seção de declarações e uma seção de comandos.

<Programa> ::= ":" DECLARACOES <ListaDeclaracoes> ":" PROGRAMA <ListaComandos>
<ListaDeclaracoes> ::= <Declaracao> <OutrasDeclaracoes>
<OutrasDeclaracoes> ::= <ListaDeclaracoes> | ε
<Declaracao> ::= NAME ":" <TipoVar>
<TipoVar> ::= INTEIRO | REAL | TEXTO | LOGICO


3.2. Comandos

A gramática suporta comandos básicos de E/S, atribuição e estruturas de controle.

<ListaComandos> ::= <Comando> <ListaComandos> | ε
<Comando> ::= <ComandoAtribuicao>
           | <ComandoEntrada>
           | <ComandoSaida>
           | <ComandoCondicao>
           | <ComandoRepeticao>
           | <SubAlgoritmo>
           | COMMENT

<ComandoAtribuicao> ::= NAME ATRIB <ExpressaoAritmetica>
<ComandoEntrada> ::= LEIA NAME
<ComandoSaida> ::= ESCREVA <TipoSaida>
<TipoSaida> ::= NAME | CADEIA

<ComandoCondicao> ::= SE <ExpressaoRelacional> ENTAO <ListaComandos> <ContraCondicao> FIM
<ContraCondicao> ::= SENAO <ListaComandos> FIM | ε
<ComandoRepeticao> ::= ENQUANTO <ExpressaoRelacional> <ListaComandos> FIM

<SubAlgoritmo> ::= INICIO <ListaComandos> FIM


3.3. Expressões

As expressões são divididas em aritméticas e relacionais, seguindo a ordem de precedência: *// > +/- > OP_REL > E > OU.

<ExpressaoAritmetica> ::= <TermoAritmetico> <SentencaAritmetica>
<SentencaAritmetica> ::= '+' <TermoAritmetico> <SentencaAritmetica>
                      | '-' <TermoAritmetico> <SentencaAritmetica> | ε
<TermoAritmetico> ::= <FatorAritmetico> <ProposicaoAritmetica>
<ProposicaoAritmetica> ::= '*' <FatorAritmetico> <ProposicaoAritmetica>
                        | '/' <FatorAritmetico> <ProposicaoAritmetica> | ε
<FatorAritmetico> ::= NUMINT | NUMREAL | NAME | '(' <ExpressaoAritmetica> ')'

<ExpressaoRelacional> ::= <TermoRelacional> <SentencaRelacional>
<TermoRelacional> ::= <ExpressaoAritmetica> OP_REL <ExpressaoAritmetica>
                   | '(' <ExpressaoRelacional> ')'
<SentencaRelacional> ::= E_BOOL <TermoRelacional> <SentencaRelacional>
                      | OU_BOOL <TermoRelacional> <SentencaRelacional> | ε


4. Implementação do Compilador

A implementação do compilador XuLang é realizada em Python, utilizando a biblioteca PLY (Python Lex-Yacc), que facilita a construção dos analisadores léxico e sintático.

4.1. Análise Léxica (Lexer)

O Lexer em xu_compiler.py é construído com as seguintes regras de implementação:

Identificação de Palavras-chave: É utilizada uma hash map (reserved) para mapear as palavras-chave (em caixa alta) aos seus respectivos tipos de token. O Lexer verifica se um identificador (NAME) corresponde a alguma palavra-chave antes de classificá-lo como um nome de variável.

Controle de Linha: A função t_NEWLINE é crucial para manter a variável t.lexer.lineno atualizada, permitindo relatar a posição exata de erros léxicos e sintáticos.

Tratamento de Erros: A função t_error garante que caracteres inválidos sejam identificados, reportados ao usuário e ignorados para que a análise possa prosseguir (recuperação de erros simples).

4.2. Tabela de Símbolos e Análise Semântica

A fase de Análise Semântica ocorre concomitantemente à análise sintática (Parser).

Tabela de Símbolos (symbols): É um dicionário global que armazena o nome e o tipo (INTEIRO, REAL, etc.) de cada variável declarada.

# Exemplo de entrada na Tabela de Símbolos
symbols = {
    'idade': {'type': 'INTEIRO'},
    'salario': {'type': 'REAL'}
}


Checagem de Declaração: Em qualquer regra que usa um NAME (atribuição, E/S), verifica-se se a variável existe em symbols. Caso não exista, um Erro Semântico de "variável não declarada" é registrado.

Checagem de Tipos (check_assignment): Esta função verifica a compatibilidade na atribuição (<-).

Permite a promoção implícita de tipos (ex: INTEIRO para REAL).

Gera um Erro Semântico para atribuições que podem causar perda de precisão (ex: REAL para INTEIRO).

O resultado dos erros semânticos é acumulado na lista semantic_errors e reportado ao final da compilação.

4.3. Geração de Código C

O Parser não apenas verifica a sintaxe, mas também constrói o código C de saída (o código gerado).

4.3.1. Declarações

Tipo XuLang

Declaração C Gerada

Notas

INTEIRO

int varname;

Padrão C.

REAL

double varname;

Uso de double para maior precisão.

TEXTO

char varname[256];

Array de tamanho fixo para strings.

LOGICO

int varname;

Representação booleana (0 ou 1) em C.

4.3.2. Mapeamento de Comandos

Comando XuLang

Código C Gerado

Observações

var <- expr

var = expr;

Para numéricos e lógicos.

texto <- string

strcpy(texto, string);

Uso de strcpy (requer string.h) para manipular strings.

LEIA var

scanf(...)

Formatos %d, %lf e tratamento de fgets para TEXTO.

ESCREVA val

printf(...)

Uso de printf com quebra de linha (\n).

SE cond ENTAO ... SENAO ... FIM

if (cond) { ... } else { ... }

Estruturas de controle traduzidas diretamente.

E, OU

&&, ||

Operadores lógicos traduzidos para o formato C.

INICIO ... FIM

{ ... }

Usado para delimitar blocos de código em C, garantindo o escopo.

4.3.3. Composição Final

A regra de topo (p_Programa) é responsável por orquestrar a saída final:

Inclui os cabeçalhos C (stdio.h, stdlib.h, string.h).

Define a função int main() {.

Insere todas as declarações de variáveis (armazenadas em c_decls).

Insere a lista de comandos traduzidos, com indentação correta.

Finaliza com return 0; }.

Este design garante que o código C gerado seja formatado de forma limpa e seja imediatamente compilável por qualquer compilador C padrão.